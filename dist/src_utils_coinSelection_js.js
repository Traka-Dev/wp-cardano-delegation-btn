/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkada_pools_delegate"] = self["webpackChunkada_pools_delegate"] || []).push([["src_utils_coinSelection_js"],{

/***/ "./src/utils/coinSelection.js":
/*!************************************!*\
  !*** ./src/utils/coinSelection.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\");\n\n\n/**\r\n * Copied from nami-wallet-api github repo :D\r\n * Copied directly from Nami wallet github repo\r\n * small changes to make it compatible\r\n *  \r\n */\n\nvar Loader = null;\n/**\r\n * BerryPool implementation of the __Random-Improve__ coin selection algorithm.\r\n *\r\n * = Overview\r\n *\r\n * The __Random-Improve__ coin selection algorithm works in __two phases__, by\r\n * /first/ selecting UTxO entries /at random/ to pay for each of the given\r\n * outputs, and /then/ attempting to /improve/ upon each of the selections.\r\n *\r\n * === Phase 1: Random Selection\r\n *\r\n * __In this phase, the algorithm randomly selects a minimal set of UTxO__\r\n * __entries to pay for each of the given outputs.__\r\n *\r\n * During this phase, the algorithm:\r\n *\r\n *   *  processes outputs in /descending order of coin value/.\r\n *\r\n *   *  maintains a /remaining UTxO set/, initially equal to the given\r\n *      /UTxO set/ parameter.\r\n *\r\n *   *  based on every output nature, generate a /native token UTxO subset/\r\n *      to narrow down to useful UTxO\r\n *\r\n *   *  maintains an /accumulated coin selection/, which is initially /empty/.\r\n *\r\n * For each output of value __/v/__, the algorithm /randomly/ selects entries\r\n * from the /remaining UTxO set/, until the total value of selected entries is\r\n * greater than or equal to __/v/__. The selected entries are then associated\r\n * with that output, and removed from the /remaining UTxO set/.\r\n *\r\n * This phase ends when every output has been associated with a selection of\r\n * UTxO entries.\r\n *\r\n * However, if the remaining UTxO set is completely exhausted before all\r\n * outputs can be processed, the algorithm terminates with an error.\r\n *\r\n * === Phase 2: Improvement\r\n *\r\n * __In this phase, the algorithm attempts to improve upon each of the UTxO__\r\n * __selections made in the previous phase, by conservatively expanding the__\r\n * __selection made for each output.__\r\n *\r\n * During this phase, the algorithm:\r\n *\r\n *   *  processes outputs in /ascending order of coin value/.\r\n *\r\n *   *  continues to maintain the /remaining UTxO set/ produced by the previous\r\n *      phase.\r\n *\r\n *   *  maintains an /accumulated coin selection/, initiated from previous phase.\r\n *\r\n * For each output of value __/v/__, the algorithm:\r\n *\r\n *  1.  __Calculates a /target range/__ for the total value of inputs used to\r\n *      pay for that output, defined by the triplet:\r\n *\r\n *      (/minimum/, /ideal/, /maximum/) = (/v/, /2v/, /3v/)\r\n *\r\n *  2.  __Attempts to /improve/ upon the /existing UTxO selection/__ for that\r\n *      output, by repeatedly selecting additional entries at random from the\r\n *      /remaining UTxO set/, stopping when the selection can be improved upon\r\n *      no further.\r\n *\r\n *      A selection with value /v1/ is considered to be an /improvement/ over a\r\n *      selection with value /v0/ if __all__ of the following conditions are\r\n *      satisfied:\r\n *\r\n *       * __Condition 1__: we have moved closer to the /ideal/ value:\r\n *\r\n *             abs (/ideal/ − /v1/) < abs (/ideal/ − /v0/)\r\n *\r\n *       * __Condition 2__: we have not exceeded the /maximum/ value:\r\n *\r\n *             /v1/ ≤ /maximum/\r\n *\r\n *       * __Condition 3__: when counting cumulatively across all outputs\r\n *       considered so far, we have not selected more than the /maximum/ number\r\n *       of UTxO entries specified by 'limit'.\r\n *\r\n *  3.  __Creates a /change value/__ for the output, equal to the total value\r\n *      of the /final UTxO selection/ for that output minus the value /v/ of\r\n *      that output.\r\n *\r\n *  4.  __Updates the /accumulated coin selection/__:\r\n *\r\n *       * Adds the /output/ to 'outputs'.\r\n *       * Adds the /improved UTxO selection/ to 'inputs'.\r\n *       * Adds the /change value/ to 'change'.\r\n *\r\n * This phase ends when every output has been processed, __or__ when the\r\n * /remaining UTxO set/ has been exhausted, whichever occurs sooner.\r\n *\r\n * = Termination\r\n *\r\n * When both phases are complete, the algorithm terminates.\r\n *\r\n * The /accumulated coin selection/ and /remaining UTxO set/ are returned to\r\n * the caller.\r\n *\r\n * === Failure Modes\r\n *\r\n * The algorithm terminates with an __error__ if:\r\n *\r\n *  1.  The /total value/ of the initial UTxO set (the amount of money\r\n *      /available/) is /less than/ the total value of the output list (the\r\n *      amount of money /required/).\r\n *\r\n *      See: __'InputsExhaustedError'__.\r\n *\r\n *  2.  The /number/ of UTxO entries needed to pay for the requested outputs\r\n *      would /exceed/ the upper limit specified by 'limit'.\r\n *\r\n *      See: __'InputLimitExceededError'__.\r\n *\r\n * == Motivating Principles\r\n *\r\n * There are several motivating principles behind the design of the algorithm.\r\n *\r\n * === Principle 1: Dust Management\r\n *\r\n * The probability that random selection will choose dust entries from a UTxO\r\n * set increases with the proportion of dust in the set.\r\n *\r\n * Therefore, for a UTxO set with a large amount of dust, there's a high\r\n * probability that a random subset will include a large amount of dust.\r\n *\r\n * === Principle 2: Change Management\r\n *\r\n * Ideally, coin selection algorithms should, over time, create a UTxO set that\r\n * has /useful/ outputs: outputs that will allow us to process future payments\r\n * with a minimum number of inputs.\r\n *\r\n * If for each payment request of value __/v/__ we create a change output of\r\n * /roughly/ the same value __/v/__, then we will end up with a distribution of\r\n * change values that matches the typical value distribution of payment\r\n * requests.\r\n *\r\n * === Principle 3: Performance Management\r\n *\r\n * Searching the UTxO set for additional entries to improve our change outputs\r\n * is /only/ useful if the UTxO set contains entries that are sufficiently\r\n * small enough. But it is precisely when the UTxO set contains many small\r\n * entries that it is less likely for a randomly-chosen UTxO entry to push the\r\n * total above the upper bound.\r\n */\n\n/**\r\n * @typedef {Value[]} AmountList - List of 'Value' object\r\n */\n\n/**\r\n * @typedef {TransactionUnspentOutput[]} UTxOList - List of UTxO\r\n */\n\n/**\r\n * @typedef {Object} UTxOSelection - Coin Selection algorithm core object\r\n * @property {UTxOList} selection - Accumulated UTxO set.\r\n * @property {UTxOList} remaining - Remaining UTxO set.\r\n * @property {UTxOList} subset - Remaining UTxO set.\r\n * @property {Value} amount - UTxO amount of each requested token\r\n */\n\n/**\r\n * @typedef {Object} ImproveRange - ImproveRange\r\n * @property {Value} ideal - Requested amount * 2\r\n * @property {Value} maximum - Requested amount * 3\r\n */\n\n/**\r\n * @typedef {Object} SelectionResult - Coin Selection algorithm return\r\n * @property {UTxOList} input - Accumulated UTxO set.\r\n * @property {OutputList} output - Requested outputs.\r\n * @property {UTxOList} remaining - Remaining UTxO set.\r\n * @property {Value} amount - UTxO amount of each requested token\r\n * @property {Value} change - Accumulated change amount.\r\n */\n\n/**\r\n * @typedef {Object} ProtocolParameters\r\n * @property {int} minUTxO\r\n * @property {int} minFeeA\r\n * @property {int} minFeeB\r\n * @property {int} maxTxSize\r\n */\n\n/**\r\n * @type {ProtocolParameters}\r\n */\n\nvar protocolParameters = null;\n/**\r\n * CoinSelection Module.\r\n * @module src/lib/CoinSelection\r\n */\n\nvar CoinSelection = {\n  /**\r\n   * Set protocol parameters required by the algorithm\r\n   * @param {string} minUTxO\r\n   * @param {string} minFeeA\r\n   * @param {string} minFeeB\r\n   * @param {string} maxTxSize\r\n   */\n  setLoader: function setLoader(lib) {\n    Loader = {\n      Cardano: lib\n    };\n  },\n  setProtocolParameters: function setProtocolParameters(minUTxO, minFeeA, minFeeB, maxTxSize) {\n    protocolParameters = {\n      minUTxO: minUTxO,\n      minFeeA: minFeeA,\n      minFeeB: minFeeB,\n      maxTxSize: maxTxSize\n    };\n  },\n\n  /**\r\n   * Random-Improve coin selection algorithm\r\n   * @param {UTxOList} inputs - The set of inputs available for selection.\r\n   * @param {TransactionOutputs} outputs - The set of outputs requested for payment.\r\n   * @param {int} limit - A limit on the number of inputs that can be selected.\r\n   * @return {SelectionResult} - Coin Selection algorithm return\r\n   */\n  randomImprove: function randomImprove(inputs, outputs, limit) {\n    if (!protocolParameters) throw new Error('Protocol parameters not set. Use setProtocolParameters().'); //await Loader.load();\n\n    var _minUTxOValue = BigInt(outputs.len()) * BigInt(protocolParameters.minUTxO);\n    /** @type {UTxOSelection} */\n\n\n    var utxoSelection = {\n      selection: [],\n      remaining: (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(inputs),\n      // Shallow copy\n      subset: [],\n      amount: Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_str('0'))\n    };\n    var mergedOutputsAmounts = mergeOutputsAmounts(outputs); // Explode amount in an array of unique asset amount for comparison's sake\n\n    var splitOutputsAmounts = splitAmounts(mergedOutputsAmounts); // Phase 1: Select enough input\n\n    for (var i = 0; i < splitOutputsAmounts.length; i++) {\n      createSubSet(utxoSelection, splitOutputsAmounts[i]); // Narrow down for NatToken UTxO\n\n      utxoSelection = select(utxoSelection, splitOutputsAmounts[i], limit, _minUTxOValue);\n    } // Phase 2: Improve\n\n\n    splitOutputsAmounts = sortAmountList(splitOutputsAmounts);\n\n    for (var _i = 0; _i < splitOutputsAmounts.length; _i++) {\n      createSubSet(utxoSelection, splitOutputsAmounts[_i]); // Narrow down for NatToken UTxO\n\n      var range = {};\n      range.ideal = Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_str('0')).checked_add(splitOutputsAmounts[_i]).checked_add(splitOutputsAmounts[_i]);\n      range.maximum = Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_str('0')).checked_add(range.ideal).checked_add(splitOutputsAmounts[_i]);\n      improve(utxoSelection, splitOutputsAmounts[_i], limit - utxoSelection.selection.length, range);\n    } // Insure change hold enough Ada to cover included native assets and fees\n\n\n    var change = utxoSelection.amount.checked_sub(mergedOutputsAmounts);\n    var minAmount = Loader.Cardano.Value[\"new\"](Loader.Cardano.min_ada_required(change, Loader.Cardano.BigNum.from_str(protocolParameters.minUTxO)));\n    var maxFee = BigInt(protocolParameters.minFeeA) * BigInt(protocolParameters.maxTxSize) + BigInt(protocolParameters.minFeeB);\n    maxFee = Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_str(maxFee.toString()));\n    minAmount = minAmount.checked_add(maxFee);\n\n    if (compare(change, minAmount) < 0) {\n      // Not enough, add missing amount and run select one last time\n      var minAda = minAmount.checked_sub(Loader.Cardano.Value[\"new\"](change.coin())).checked_add(Loader.Cardano.Value[\"new\"](utxoSelection.amount.coin()));\n      createSubSet(utxoSelection, minAda);\n      utxoSelection = select(utxoSelection, minAda, limit, _minUTxOValue);\n    }\n\n    return {\n      input: utxoSelection.selection,\n      output: outputs,\n      remaining: utxoSelection.remaining,\n      amount: utxoSelection.amount,\n      change: utxoSelection.amount.checked_sub(mergedOutputsAmounts)\n    };\n  }\n};\n/**\r\n * Use randomSelect & descSelect algorithm to select enough UTxO to fulfill requested outputs\r\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\r\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\r\n * @param {int} limit - A limit on the number of inputs that can be selected.\r\n * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\r\n * @throws INPUT_LIMIT_EXCEEDED if the number of randomly picked inputs exceed 'limit' parameter.\r\n * @throws INPUTS_EXHAUSTED if all UTxO doesn't hold enough funds to pay for output.\r\n * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\r\n * @return {UTxOSelection} - Successful random utxo selection.\r\n */\n\nfunction select(utxoSelection, outputAmount, limit, minUTxOValue) {\n  try {\n    utxoSelection = randomSelect(cloneUTxOSelection(utxoSelection), // Deep copy in case of fallback needed\n    outputAmount, limit - utxoSelection.selection.length, minUTxOValue);\n  } catch (e) {\n    if (e.message === 'INPUT_LIMIT_EXCEEDED') {\n      // Limit reached : Fallback on DescOrdAlgo\n      utxoSelection = descSelect(utxoSelection, outputAmount, limit - utxoSelection.selection.length, minUTxOValue);\n    } else {\n      throw e;\n    }\n  }\n\n  return utxoSelection;\n}\n/**\r\n * Randomly select enough UTxO to fulfill requested outputs\r\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\r\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\r\n * @param {int} limit - A limit on the number of inputs that can be selected.\r\n * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\r\n * @throws INPUT_LIMIT_EXCEEDED if the number of randomly picked inputs exceed 'limit' parameter.\r\n * @throws INPUTS_EXHAUSTED if all UTxO doesn't hold enough funds to pay for output.\r\n * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\r\n * @return {UTxOSelection} - Successful random utxo selection.\r\n */\n\n\nfunction randomSelect(utxoSelection, outputAmount, limit, minUTxOValue) {\n  var nbFreeUTxO = utxoSelection.subset.length; // If quantity is met, return subset into remaining list and exit\n\n  if (isQtyFulfilled(outputAmount, utxoSelection.amount, minUTxOValue, nbFreeUTxO)) {\n    utxoSelection.remaining = [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(utxoSelection.remaining), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(utxoSelection.subset));\n    utxoSelection.subset = [];\n    return utxoSelection;\n  }\n\n  if (limit <= 0) {\n    throw new Error('INPUT_LIMIT_EXCEEDED');\n  }\n\n  if (nbFreeUTxO <= 0) {\n    if (isQtyFulfilled(outputAmount, utxoSelection.amount, 0, 0)) {\n      throw new Error('MIN_UTXO_ERROR');\n    }\n\n    throw new Error('INPUTS_EXHAUSTED');\n  }\n  /** @type {TransactionUnspentOutput} utxo */\n\n\n  var utxo = utxoSelection.subset.splice(Math.floor(Math.random() * nbFreeUTxO), 1).pop();\n  utxoSelection.selection.push(utxo);\n  utxoSelection.amount = addAmounts(utxo.output().amount(), utxoSelection.amount);\n  return randomSelect(utxoSelection, outputAmount, limit - 1, minUTxOValue);\n}\n/**\r\n * Select enough UTxO in DESC order to fulfill requested outputs\r\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\r\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\r\n * @param {int} limit - A limit on the number of inputs that can be selected.\r\n * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\r\n * @throws INPUT_LIMIT_EXCEEDED if the number of randomly picked inputs exceed 'limit' parameter.\r\n * @throws INPUTS_EXHAUSTED if all UTxO doesn't hold enough funds to pay for output.\r\n * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\r\n * @return {UTxOSelection} - Successful random utxo selection.\r\n */\n\n\nfunction descSelect(utxoSelection, outputAmount, limit, minUTxOValue) {\n  // Sort UTxO subset in DESC order for required Output unit type\n  utxoSelection.subset = utxoSelection.subset.sort(function (a, b) {\n    return Number(searchAmountValue(outputAmount, b.output().amount()) - searchAmountValue(outputAmount, a.output().amount()));\n  });\n\n  do {\n    if (limit <= 0) {\n      throw new Error('INPUT_LIMIT_EXCEEDED');\n    }\n\n    if (utxoSelection.subset.length <= 0) {\n      if (isQtyFulfilled(outputAmount, utxoSelection.amount, 0, 0)) {\n        throw new Error('MIN_UTXO_ERROR');\n      }\n\n      throw new Error('INPUTS_EXHAUSTED');\n    }\n    /** @type {TransactionUnspentOutput} utxo */\n\n\n    var utxo = utxoSelection.subset.splice(0, 1).pop();\n    utxoSelection.selection.push(utxo);\n    utxoSelection.amount = addAmounts(utxo.output().amount(), utxoSelection.amount);\n    limit--;\n  } while (!isQtyFulfilled(outputAmount, utxoSelection.amount, minUTxOValue, utxoSelection.subset.length - 1)); // Quantity is met, return subset into remaining list and return selection\n\n\n  utxoSelection.remaining = [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(utxoSelection.remaining), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(utxoSelection.subset));\n  utxoSelection.subset = [];\n  return utxoSelection;\n}\n/**\r\n * Try to improve selection by increasing input amount in [2x,3x] range.\r\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\r\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\r\n * @param {int} limit - A limit on the number of inputs that can be selected.\r\n * @param {ImproveRange} range - Improvement range target values\r\n */\n\n\nfunction improve(utxoSelection, outputAmount, limit, range) {\n  var nbFreeUTxO = utxoSelection.subset.length;\n\n  if (compare(utxoSelection.amount, range.ideal) >= 0 || nbFreeUTxO <= 0 || limit <= 0) {\n    // Return subset in remaining\n    utxoSelection.remaining = [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(utxoSelection.remaining), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(utxoSelection.subset));\n    utxoSelection.subset = [];\n    return;\n  }\n  /** @type {TransactionUnspentOutput} utxo */\n\n\n  var utxo = utxoSelection.subset.splice(Math.floor(Math.random() * nbFreeUTxO), 1).pop();\n  var newAmount = Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_str('0')).checked_add(utxo.output().amount()).checked_add(outputAmount);\n\n  if (abs(getAmountValue(range.ideal) - getAmountValue(newAmount)) < abs(getAmountValue(range.ideal) - getAmountValue(outputAmount)) && compare(newAmount, range.maximum) <= 0) {\n    utxoSelection.selection.push(utxo);\n    utxoSelection.amount = addAmounts(utxo.output().amount(), utxoSelection.amount);\n    limit--;\n  } else {\n    utxoSelection.remaining.push(utxo);\n  }\n\n  return improve(utxoSelection, outputAmount, limit, range);\n}\n/**\r\n * Compile all required outputs to a flat amounts list\r\n * @param {TransactionOutputs} outputs - The set of outputs requested for payment.\r\n * @return {Value} - The compiled set of amounts requested for payment.\r\n */\n\n\nfunction mergeOutputsAmounts(outputs) {\n  var compiledAmountList = Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_str('0'));\n\n  for (var i = 0; i < outputs.len(); i++) {\n    compiledAmountList = addAmounts(outputs.get(i).amount(), compiledAmountList);\n  }\n\n  return compiledAmountList;\n}\n/**\r\n * Add up an Amounts List values to another Amounts List\r\n * @param {Value} amounts - Set of amounts to be added.\r\n * @param {Value} compiledAmounts - The compiled set of amounts.\r\n * @return {Value}\r\n */\n\n\nfunction addAmounts(amounts, compiledAmounts) {\n  return compiledAmounts.checked_add(amounts);\n}\n/**\r\n * Split amounts contained in a single {Value} object in separate {Value} objects\r\n * @param {Value} amounts - Set of amounts to be split.\r\n * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\r\n * @return {AmountList}\r\n */\n\n\nfunction splitAmounts(amounts) {\n  var splitAmounts = [];\n\n  if (amounts.multiasset()) {\n    var mA = amounts.multiasset();\n\n    for (var i = 0; i < mA.keys().len(); i++) {\n      var scriptHash = mA.keys().get(i);\n\n      for (var j = 0; j < mA.get(scriptHash).keys().len(); j++) {\n        var _assets = Loader.Cardano.Assets[\"new\"]();\n\n        var assetName = mA.get(scriptHash).keys().get(j);\n\n        _assets.insert(Loader.Cardano.AssetName.from_bytes(assetName.to_bytes()), Loader.Cardano.BigNum.from_bytes(mA.get(scriptHash).get(assetName).to_bytes()));\n\n        var _multiasset = Loader.Cardano.MultiAsset[\"new\"]();\n\n        _multiasset.insert(Loader.Cardano.ScriptHash.from_bytes(scriptHash.to_bytes()), _assets);\n\n        var _value = Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_str('0'));\n\n        _value.set_multiasset(_multiasset);\n\n        splitAmounts.push(_value);\n      }\n    }\n  } // Order assets by qty DESC\n\n\n  splitAmounts = sortAmountList(splitAmounts, 'DESC'); // Insure lovelace is last to account for min ada requirement\n\n  splitAmounts.push(Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_bytes(amounts.coin().to_bytes())));\n  return splitAmounts;\n}\n/**\r\n * Sort a mismatched AmountList ASC/DESC\r\n * @param {AmountList} amountList - Set of mismatched amounts to be sorted.\r\n * @param {string} [sortOrder=ASC] - Order\r\n * @return {AmountList} - The sorted AmountList\r\n */\n\n\nfunction sortAmountList(amountList) {\n  var sortOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ASC';\n  return amountList.sort(function (a, b) {\n    var sortInt = sortOrder === 'DESC' ? BigInt(-1) : BigInt(1);\n    return Number((getAmountValue(a) - getAmountValue(b)) * sortInt);\n  });\n}\n/**\r\n * Return BigInt amount value\r\n * @param {Value} amount\r\n * @return {bigint}\r\n */\n\n\nfunction getAmountValue(amount) {\n  var val = BigInt(0);\n  var lovelace = BigInt(amount.coin().to_str());\n\n  if (lovelace > 0) {\n    val = lovelace;\n  } else if (amount.multiasset() && amount.multiasset().len() > 0) {\n    var scriptHash = amount.multiasset().keys().get(0);\n    var assetName = amount.multiasset().get(scriptHash).keys().get(0);\n    val = BigInt(amount.multiasset().get(scriptHash).get(assetName).to_str());\n  }\n\n  return val;\n}\n/**\r\n * Search & Return BigInt amount value\r\n * @param {Value} needle\r\n * @param {Value} haystack\r\n * @return {bigint}\r\n */\n\n\nfunction searchAmountValue(needle, haystack) {\n  var val = BigInt(0);\n  var lovelace = BigInt(needle.coin().to_str());\n\n  if (lovelace > 0) {\n    val = BigInt(haystack.coin().to_str());\n  } else if (needle.multiasset() && haystack.multiasset() && needle.multiasset().len() > 0 && haystack.multiasset().len() > 0) {\n    var scriptHash = needle.multiasset().keys().get(0);\n    var assetName = needle.multiasset().get(scriptHash).keys().get(0);\n    val = BigInt(haystack.multiasset().get(scriptHash).get(assetName).to_str());\n  }\n\n  return val;\n}\n/**\r\n * Narrow down remaining UTxO set in case of native token, use full set for lovelace\r\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\r\n * @param {Value} output - Single compiled output qty requested for payment.\r\n */\n\n\nfunction createSubSet(utxoSelection, output) {\n  if (BigInt(output.coin().to_str()) < BigInt(1)) {\n    var subset = [];\n    var remaining = [];\n\n    for (var i = 0; i < utxoSelection.remaining.length; i++) {\n      if (compare(utxoSelection.remaining[i].output().amount(), output) !== undefined) {\n        subset.push(utxoSelection.remaining[i]);\n      } else {\n        remaining.push(utxoSelection.remaining[i]);\n      }\n    }\n\n    utxoSelection.subset = subset;\n    utxoSelection.remaining = remaining;\n  } else {\n    utxoSelection.subset = utxoSelection.remaining.splice(0, utxoSelection.remaining.length);\n  }\n}\n/**\r\n * Is Quantity Fulfilled Condition - Handle 'minUTxOValue' protocol parameter.\r\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\r\n * @param {Value} cumulatedAmount - Single compiled accumulated UTxO qty.\r\n * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\r\n * @param {int} nbFreeUTxO - Number of free UTxO available.\r\n * @return {boolean}\r\n */\n\n\nfunction isQtyFulfilled(outputAmount, cumulatedAmount, minUTxOValue, nbFreeUTxO) {\n  var amount = outputAmount;\n\n  if (minUTxOValue && BigInt(outputAmount.coin().to_str()) > 0) {\n    var minAmount = Loader.Cardano.Value[\"new\"](Loader.Cardano.min_ada_required(cumulatedAmount, Loader.Cardano.BigNum.from_str(minUTxOValue.toString()))); // Lovelace min amount to cover assets and number of output need to be met\n\n    if (compare(cumulatedAmount, minAmount) < 0) return false; // If requested Lovelace lower than minAmount, plan for change\n\n    if (compare(outputAmount, minAmount) < 0) {\n      amount = minAmount.checked_add(Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_str(protocolParameters.minUTxO)));\n    } // Try covering the max fees\n\n\n    if (nbFreeUTxO > 0) {\n      var maxFee = BigInt(protocolParameters.minFeeA) * BigInt(protocolParameters.maxTxSize) + BigInt(protocolParameters.minFeeB);\n      maxFee = Loader.Cardano.Value[\"new\"](Loader.Cardano.BigNum.from_str(maxFee.toString()));\n      amount = amount.checked_add(maxFee);\n    }\n  }\n\n  return compare(cumulatedAmount, amount) >= 0;\n}\n/**\r\n * Return a deep copy of UTxOSelection\r\n * @param {UTxOSelection} utxoSelection\r\n * @return {UTxOSelection} Clone - Deep copy\r\n */\n\n\nfunction cloneUTxOSelection(utxoSelection) {\n  return {\n    selection: cloneUTxOList(utxoSelection.selection),\n    remaining: cloneUTxOList(utxoSelection.remaining),\n    subset: cloneUTxOList(utxoSelection.subset),\n    amount: cloneValue(utxoSelection.amount)\n  };\n}\n/**\r\n * Return a deep copy of an UTxO List\r\n * @param {UTxOList} utxoList\r\n * @return {UTxOList} Cone - Deep copy\r\n */\n\n\nvar cloneUTxOList = function cloneUTxOList(utxoList) {\n  return utxoList.map(function (utxo) {\n    return Loader.Cardano.TransactionUnspentOutput.from_bytes(utxo.to_bytes());\n  });\n};\n/**\r\n * Return a deep copy of a Value object\r\n * @param {Value} value\r\n * @return {Value} Cone - Deep copy\r\n */\n\n\nvar cloneValue = function cloneValue(value) {\n  return Loader.Cardano.Value.from_bytes(value.to_bytes());\n}; // Helper\n\n\nfunction abs(big) {\n  return big < 0 ? big * BigInt(-1) : big;\n}\n/**\r\n * Compare a candidate value to the one in a group if present\r\n * @param {Value} group\r\n * @param {Value} candidate\r\n * @return {int} - -1 group lower, 0 equal, 1 group higher, undefined if no match\r\n */\n\n\nfunction compare(group, candidate) {\n  var gQty = BigInt(group.coin().to_str());\n  var cQty = BigInt(candidate.coin().to_str());\n\n  if (candidate.multiasset()) {\n    var cScriptHash = candidate.multiasset().keys().get(0);\n    var cAssetName = candidate.multiasset().get(cScriptHash).keys().get(0);\n\n    if (group.multiasset() && group.multiasset().len()) {\n      if (group.multiasset().get(cScriptHash) && group.multiasset().get(cScriptHash).get(cAssetName)) {\n        gQty = BigInt(group.multiasset().get(cScriptHash).get(cAssetName).to_str());\n        cQty = BigInt(candidate.multiasset().get(cScriptHash).get(cAssetName).to_str());\n      } else {\n        return undefined;\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  return gQty >= cQty ? gQty === cQty ? 0 : 1 : -1;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoinSelection);\n\n//# sourceURL=webpack://ada-pools-delegate/./src/utils/coinSelection.js?");

/***/ })

}])